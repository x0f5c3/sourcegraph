import { Literal } from './token'

interface Access {
    name: string
    fields?: Access[]
}

export const SELECTORS: Access[] = [
    {
        name: 'repo',
    },
    {
        name: 'file',
        fields: [{ name: 'directory' }, { name: 'path' }],
    },
    {
        name: 'content',
    },
    {
        name: 'symbol',
        fields: [
            { name: 'Constructor'},
            { name: 'Exception'},
            { name: 'File'},
            { name: 'L1Header'},
            { name: 'L2Header'},
            { name: 'L3Header'},
            { name: 'L4Header'},
            { name: 'L5Header'},
            { name: 'L6Header'},
            { name: 'NAME'},
            { name: 'RecordField'},
            { name: 'accelerators'},
            { name: 'accessor'},
            { name: 'activeBindingFunc'},
            { name: 'alias'},
            { name: 'altstep'},
            { name: 'anchor'},
            { name: 'annotation'},
            { name: 'anon'},
            { name: 'anonMember'},
            { name: 'antfile'},
            { name: 'architecture'},
            { name: 'arg'},
            { name: 'array'},
            { name: 'article'},
            { name: 'artifactId'},
            { name: 'assembly'},
            { name: 'assert'},
            { name: 'attribute'},
            { name: 'augroup'},
            { name: 'autovar'},
            { name: 'benchmark'},
            { name: 'bibitem'},
            { name: 'bitmap'},
            { name: 'block'},
            { name: 'blockData'},
            { name: 'book'},
            { name: 'booklet'},
            { name: 'boolean'},
            { name: 'build'},
            { name: 'callback'},
            { name: 'category'},
            { name: 'ccflag'},
            { name: 'cell'},
            { name: 'chapter'},
            { name: 'checker'},
            { name: 'choice'},
            { name: 'chunklabel'},
            { name: 'citation'},
            { name: 'class'},
            { name: 'clocking'},
            { name: 'combo'},
            { name: 'command'},
            { name: 'common'},
            { name: 'component'},
            { name: 'cond'},
            { name: 'condition'},
            { name: 'conference'},
            { name: 'config'},
            { name: 'const'},
            { name: 'constant'},
            { name: 'constraint'},
            { name: 'constructor'},
            { name: 'context'},
            { name: 'counter'},
            { name: 'covergroup'},
            { name: 'cursor'},
            { name: 'custom'},
            { name: 'data'},
            { name: 'database'},
            { name: 'dataframe'},
            { name: 'def'},
            { name: 'define'},
            { name: 'definition'},
            { name: 'delegate'},
            { name: 'deletedFile'},
            { name: 'derivedMode'},
            { name: 'describe'},
            { name: 'dialog'},
            { name: 'directory'},
            { name: 'division'},
            { name: 'document'},
            { name: 'domain'},
            { name: 'edesc'},
            { name: 'element'},
            { name: 'entity'},
            { name: 'entry'},
            { name: 'entryspec'},
            { name: 'enum'},
            { name: 'enumConstant'},
            { name: 'enumerator'},
            { name: 'environment'},
            { name: 'error'},
            { name: 'event'},
            { name: 'exception'},
            { name: 'externvar'},
            { name: 'face'},
            { name: 'fd'},
            { name: 'feature'},
            { name: 'field'},
            { name: 'filename'},
            { name: 'font'},
            { name: 'footnote'},
            { name: 'formal'},
            { name: 'format'},
            { name: 'fragment'},
            { name: 'framesubtitle'},
            { name: 'frametitle'},
            { name: 'fun'},
            { name: 'func'},
            { name: 'function'},
            { name: 'functionVar'},
            { name: 'functor'},
            { name: 'gem'},
            { name: 'generator'},
            { name: 'generic'},
            { name: 'getter'},
            { name: 'global'},
            { name: 'globalVar'},
            { name: 'grammar'},
            { name: 'group'},
            { name: 'groupId'},
            { name: 'guard'},
            { name: 'handler'},
            { name: 'header'},
            { name: 'heading1'},
            { name: 'heading2'},
            { name: 'heading3'},
            { name: 'heredoc'},
            { name: 'hunk'},
            { name: 'icon'},
            { name: 'id'},
            { name: 'identifier'},
            { name: 'ifclass'},
            { name: 'implementation'},
            { name: 'import'},
            { name: 'inbook'},
            { name: 'incollection'},
            { name: 'index'},
            { name: 'infoitem'},
            { name: 'inline'},
            { name: 'inproceedings'},
            { name: 'inputSection'},
            { name: 'instance'},
            { name: 'integer'},
            { name: 'interface'},
            { name: 'iparam'},
            { name: 'it'},
            { name: 'kconfig'},
            { name: 'key'},
            { name: 'keyword'},
            { name: 'kind'},
            { name: 'l4subsection'},
            { name: 'l5subsection'},
            { name: 'label'},
            { name: 'langdef'},
            { name: 'langstr'},
            { name: 'library'},
            { name: 'list'},
            { name: 'literal'},
            { name: 'local'},
            { name: 'localVariable'},
            { name: 'localvar'},
            { name: 'loggerSection'},
            { name: 'ltlibrary'},
            { name: 'macro'},
            { name: 'macroParameter'},
            { name: 'macrofile'},
            { name: 'macroparam'},
            { name: 'mainMenu'},
            { name: 'makefile'},
            { name: 'man'},
            { name: 'manual'},
            { name: 'map'},
            { name: 'mastersthesis'},
            { name: 'matchedTemplate'},
            { name: 'member'},
            { name: 'menu'},
            { name: 'message'},
            { name: 'method'},
            { name: 'methodSpec'},
            { name: 'minorMode'},
            { name: 'misc'},
            { name: 'mixin'},
            { name: 'mlconn'},
            { name: 'mlprop'},
            { name: 'mltable'},
            { name: 'modifiedFile'},
            { name: 'modport'},
            { name: 'module'},
            { name: 'modulepar'},
            { name: 'multitask'},
            { name: 'mxtag'},
            { name: 'name'},
            { name: 'nameattr'},
            { name: 'namedPattern'},
            { name: 'namedTemplate'},
            { name: 'namelist'},
            { name: 'namespace'},
            { name: 'net'},
            { name: 'nettype'},
            { name: 'newFile'},
            { name: 'node'},
            { name: 'notation'},
            { name: 'nsprefix'},
            { name: 'null'},
            { name: 'number'},
            { name: 'object'},
            { name: 'oneof'},
            { name: 'oparam'},
            { name: 'operator'},
            { name: 'optenable'},
            { name: 'option'},
            { name: 'optwith'},
            { name: 'package'},
            { name: 'packageName'},
            { name: 'packspec'},
            { name: 'paragraph'},
            { name: 'param'},
            { name: 'parameter'},
            { name: 'parameterEntity'},
            { name: 'part'},
            { name: 'patch'},
            { name: 'path'},
            { name: 'pattern'},
            { name: 'phandler'},
            { name: 'phdthesis'},
            { name: 'pkg'},
            { name: 'placeholder'},
            { name: 'play'},
            { name: 'port'},
            { name: 'probe'},
            { name: 'procedure'},
            { name: 'proceedings'},
            { name: 'process'},
            { name: 'program'},
            { name: 'project'},
            { name: 'property'},
            { name: 'protected'},
            { name: 'protectspec'},
            { name: 'protocol'},
            { name: 'protodef'},
            { name: 'prototype'},
            { name: 'publication'},
            { name: 'qmp'},
            { name: 'qualname'},
            { name: 'receiver'},
            { name: 'record'},
            { name: 'regex'},
            { name: 'region'},
            { name: 'register'},
            { name: 'reopen'},
            { name: 'repoid'},
            { name: 'repositoryId'},
            { name: 'repr'},
            { name: 'resource'},
            { name: 'response'},
            { name: 'role'},
            { name: 'root'},
            { name: 'rpc'},
            { name: 'rule'},
            { name: 'run'},
            { name: 'schema'},
            { name: 'script'},
            { name: 'section'},
            { name: 'sectionGroup'},
            { name: 'selector'},
            { name: 'sequence'},
            { name: 'server'},
            { name: 'service'},
            { name: 'set'},
            { name: 'setter'},
            { name: 'signal'},
            { name: 'signature'},
            { name: 'singletonMethod'},
            { name: 'slot'},
            { name: 'source'},
            { name: 'sourcefile'},
            { name: 'step'},
            { name: 'string'},
            { name: 'struct'},
            { name: 'structure'},
            { name: 'stylesheet'},
            { name: 'subdir'},
            { name: 'submethod'},
            { name: 'submodule'},
            { name: 'subparagraph'},
            { name: 'subprogram'},
            { name: 'subprogspec'},
            { name: 'subroutine'},
            { name: 'subroutineDeclaration'},
            { name: 'subsection'},
            { name: 'subspec'},
            { name: 'subst'},
            { name: 'substdef'},
            { name: 'subsubsection'},
            { name: 'subtitle'},
            { name: 'subtype'},
            { name: 'symbol'},
            { name: 'synonym'},
            { name: 'table'},
            { name: 'tag'},
            { name: 'talias'},
            { name: 'target'},
            { name: 'task'},
            { name: 'taskspec'},
            { name: 'techreport'},
            { name: 'template'},
            { name: 'test'},
            { name: 'testcase'},
            { name: 'theme'},
            { name: 'theorem'},
            { name: 'thriftFile'},
            { name: 'throwsparam'},
            { name: 'timer'},
            { name: 'title'},
            { name: 'token'},
            { name: 'toplevelVariable'},
            { name: 'tparam'},
            { name: 'trait'},
            { name: 'trigger'},
            { name: 'type'},
            { name: 'typealias'},
            { name: 'typedef'},
            { name: 'typespec'},
            { name: 'union'},
            { name: 'unit'},
            { name: 'unknown'},
            { name: 'unpublished'},
            { name: 'username'},
            { name: 'using'},
            { name: 'val'},
            { name: 'value'},
            { name: 'var'},
            { name: 'varalias'},
            { name: 'variable'},
            { name: 'varspec'},
            { name: 'vector'},
            { name: 'version'},
            { name: 'view'},
            { name: 'virtual'},
            { name: 'vresource'},
            { name: 'wrapper'},
            { name: 'xinput'},
            { name: 'xtask'},
        ],
    },
    {
        name: 'commit',
        fields: [{ name: 'diff', fields: [{ name: 'added' }, { name: 'removed' }] }],
    },
]

/**
 * Returns all paths rooted at a {@link selector} up to {@param depth}.
 */
export const selectDiscreteValues = (selectors: Access[], depth: number): string[] => {
    if (depth < 0) {
        return []
    }
    const paths: string[] = []
    for (const entry of selectors) {
        paths.push(`${entry.name}`)
        if (entry.fields) {
            paths.push(...selectDiscreteValues(entry.fields, depth - 1).map(value => `${entry.name}.` + value))
        }
    }
    return paths
}

export const selectorCompletion = (value: Literal | undefined): string[] => {
    if (!value) {
        return selectDiscreteValues(SELECTORS, 0)
    }

    if (value.value.endsWith('.') || value.value.split('.').length > 1) {
        // Resolve completions to greater depth for `foo.` if the value is `foo.` or `foo.bar`.
        const kind = value.value.split('.')[0]
        return selectDiscreteValues(
            SELECTORS.filter(value => value.name === kind),
            2
        )
    }
    return selectDiscreteValues(SELECTORS, 0)
}
